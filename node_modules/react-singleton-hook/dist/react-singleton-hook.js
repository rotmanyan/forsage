(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactSingletonHook = {}, global.React, global.ReactDOM));
}(this, (function (exports, React, reactDom) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  var SingleItemContainer = function SingleItemContainer(_ref) {
    var initValue = _ref.initValue,
        useHookBody = _ref.useHookBody,
        applyStateChange = _ref.applyStateChange;
    var lastState = React.useRef(initValue);

    if (typeof useHookBody !== 'function') {
      throw new Error("function expected as hook body parameter. got " + typeof useHookBody);
    }

    var val = useHookBody(); //useLayoutEffect is safe from SSR perspective because SingleItemContainer should never be rendered on server

    React.useLayoutEffect(function () {
      if (lastState.current !== val) {
        lastState.current = val;
        applyStateChange(val);
      }
    }, [applyStateChange, val]);
    return null;
  };

  var warning = function warning(message) {
    if (console && console.warn) {
      console.warn(message);
    }
  };

  var batch = function batch(cb) {
    return reactDom.unstable_batchedUpdates(cb);
  };
  var mount = function mount(C) {
    if (window && window.document) {
      reactDom.render( /*#__PURE__*/React__default['default'].createElement(C, null), window.document.createElement('div'));
    } else {
      warning('Can not mount SingletonHooksContainer on server side. ' + 'Did you manage to run useEffect on server? ' + 'Please mount SingletonHooksContainer into your components tree manually.');
    }
  };

  var SingletonHooksContainerMounted = false;
  var SingletonHooksContainerRendered = false;
  var SingletonHooksContainerMountedAutomatically = false;
  var mountQueue = [];

  var mountIntoContainerDefault = function mountIntoContainerDefault(item) {
    mountQueue.push(item);
  };

  var mountIntoContainer = mountIntoContainerDefault;
  var SingletonHooksContainer = function SingletonHooksContainer() {
    SingletonHooksContainerRendered = true;
    React.useEffect(function () {
      if (SingletonHooksContainerMounted) {
        warning('SingletonHooksContainer is mounted second time. ' + 'You should mount SingletonHooksContainer before any other component and never unmount it.' + 'Alternatively, dont use SingletonHooksContainer it at all, we will handle that for you.');
      }

      SingletonHooksContainerMounted = true;
      return function () {
        return  warning('SingletonHooksContainer is removed from DOM. its not supported, singleton hooks will stop updating.');
      };
    }, []);

    var _useState = React.useState([]),
        hooks = _useState[0],
        setHooks = _useState[1];

    React.useEffect(function () {
      mountIntoContainer = function mountIntoContainer(item) {
        return setHooks(function (hooks) {
          return [].concat(hooks, [item]);
        });
      };

      setHooks(mountQueue);
    }, []);
    return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, hooks.map(function (h, i) {
      return /*#__PURE__*/React__default['default'].createElement(SingleItemContainer, _extends({}, h, {
        key: i
      }));
    }));
  };
  var addHook = function addHook(hook) {
    if (!SingletonHooksContainerRendered && !SingletonHooksContainerMountedAutomatically) {
      SingletonHooksContainerMountedAutomatically = true;
      mount(SingletonHooksContainer);
    }

    mountIntoContainer(hook);
  };

  var singletonHook = function singletonHook(initValue, useHookBody) {
    var mounted = false;
    var initStateCalculated = false;
    var lastKnownState = undefined;
    var consumers = [];

    var applyStateChange = function applyStateChange(newState) {
      lastKnownState = newState;
      batch(function () {
        return consumers.forEach(function (c) {
          return c(newState);
        });
      });
    };

    var stateInitializer = function stateInitializer() {
      if (!initStateCalculated) {
        lastKnownState = typeof initValue === 'function' ? initValue() : initValue;
        initStateCalculated = true;
      }

      return lastKnownState;
    };

    return function () {
      var _useState = React.useState(stateInitializer),
          state = _useState[0],
          setState = _useState[1];

      React.useEffect(function () {
        if (!mounted) {
          mounted = true;
          addHook({
            initValue: initValue,
            useHookBody: useHookBody,
            applyStateChange: applyStateChange
          });
        }

        consumers.push(setState);

        if (lastKnownState !== state) {
          setState(lastKnownState);
        }

        return function () {
          consumers.splice(consumers.indexOf(setState), 1);
        }; // eslint-disable-next-line react-hooks/exhaustive-deps
      }, []);
      return state;
    };
  };

  var ReactSingletonHook = {
    singletonHook: singletonHook,
    SingletonHooksContainer: SingletonHooksContainer
  };

  exports.SingletonHooksContainer = SingletonHooksContainer;
  exports.default = ReactSingletonHook;
  exports.singletonHook = singletonHook;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
